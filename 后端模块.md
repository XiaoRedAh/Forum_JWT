# 账号信息设置

## 前置准备工作

db_account_details数据表存放账号详细信息
```sql
CREATE TABLE db_account_details  (
  `id` int NOT NULL,
  `gender` tinyint(255) NULL,
  `phone` varchar(255) NULL,
  `qq` varchar(255) NULL,
  `wx` varchar(255) NULL,
  `desc` varchar(255) NULL,
  PRIMARY KEY (`id`)
);
```

easycode插件自动生成对应的实体类，service，serviceimpl，mapper

```java
/**
 * (AccountDetails)表实体类
 *
 * @author makejava
 * @since 2023-08-29 15:52:08
 */
@SuppressWarnings("serial")
@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("db_account_details")
public class AccountDetails implements BaseData {
    @TableId
    private Integer id;
    private Integer gender;
    private String phone;
    private String qq;
    private String wx;
    @TableField("`desc`") //desc是sql语句的关键字，需要区分一下
    private String desc;
}

```

## 展示详细信息

com/xiaoRed/entity/vo/response/AccountDetailsVo.java
数据库查询到用户详细信息，封装为AccountDetailsVo对象返回给前端
```java
/**
 * 数据库查询到用户详细信息，封装为vo对象返回给前端
 */
@Data
public class AccountDetailsVo {
    private Integer gender;
    private String phone;
    private String qq;
    private String wx;
    private String desc;
}
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 获取用户详细信息，封装为vo对象，展示到前端
     * @param id JwtAuthorizeFilter已经往请求域中塞进了用户id，直接从请求域里取出来就行
     * @return
     */
    @GetMapping("/details")
    public RestBean<AccountDetailsVo> details(@RequestAttribute(Const.ATTR_USER_ID) int id){
        //如果之前没有保存过账户详细信息，数据表中是没有对应id的数据的，这时new一个空的即可
        AccountDetails accountDetails = Optional.
                ofNullable(accountDetailsService.findAccountDetailsById(id))
                .orElseGet(AccountDetails::new);
        return RestBean.success(accountDetails.asViewObject(AccountDetailsVo.class));
    }
```

com/xiaoRed/service/impl/AccountDetailsServiceImpl.java
```java
    /**
     * 通过用户id从表中找到该条记录并返回给前端显示
     * @param id 用户id
     * @return
     */
    @Override
    public AccountDetails findAccountDetailsById(int id) {
        return this.getById(id);
    }
```

## 保存详细信息

com/xiaoRed/entity/vo/request/DetailsSaveVo.java
将请求中携带的账户信息设置提交的内容封装为一个DetailsSaveVo对象
```java
/**
 * 账户信息设置提交的内容封装为一个vo
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class DetailsSaveVo {
    @Pattern(regexp = "^[a-zA-Z0-9\\u4e00-\\u9fa5]+$")//不允许包含特殊字符
    @Length(min = 1, max = 10)
    private String username;
    //0表示男，1表示女
    @Max(1)
    @Min(0)
    private Integer gender;
    @Length(max = 11)
    private String phone;
    @Length(max = 13)
    private String qq;
    @Length(max = 20)
    private String wx;
    @Length(max = 200)
    private String desc;
}
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 保存账户详细信息
     * @param id JwtAuthorizeFilter已经往请求域中塞进了用户id，直接从请求域里取出来就行
     * @param vo 前端保存账户详细信息表单提交的内容封装为一个vo
     * @return
     */
    @PostMapping("/save-details")
    public RestBean<Void> saveDetails(@RequestAttribute(Const.ATTR_USER_ID) int id, @RequestBody @Valid DetailsSaveVo vo){
        boolean isSuccess = accountDetailsService.saveAccountDetails(id, vo);
        return  isSuccess ? RestBean.success() : RestBean.failure(400, "此用户名已被其他用户使用，请重新设置");
    }
```

com/xiaoRed/service/impl/AccountDetailsServiceImpl.java
```java
    /**
     * 保存账户详细信息，涉及到改两张表
     * 改用户名涉及到db_account表，其他的涉及db_account_details表
     * @param id 用户id
     * @param vo 前端提交的账户详细信息表单
     * @return 是否保存成功
     */
    @Override
    @Transactional
    public boolean saveAccountDetails(int id, DetailsSaveVo vo) {
        Account account = accountService.findAccountByNameOrEmail(vo.getUsername()); //从用户表中查有无同名的用户
        if(account == null || account.getId() == id){ //如果没有同名用户或同名用户就是自己，才可以进一步地修改
            //db_account表中修改用户名
            accountService.update()
                    .eq("id", id)
                    .set("username", vo.getUsername())
                    .update();
            //db_account_details表中修改用户详细信息。如果表中无对应id数据，则插入，否则更新
            this.saveOrUpdate(new AccountDetails(id, vo.getGender(), vo.getPhone(), vo.getQq(),
                    vo.getWx(), vo.getDesc()));
            return true;
        }
        return false;
    }
```

# 修改电子邮箱

com/xiaoRed/entity/vo/request/ModifyEmailVo.java
前端传过来的新电子邮箱以及验证码封装为vo
```java
/**
 * 修改账号绑定的电子邮箱功能：前端传过来的新电子邮箱以及验证码封装为vo
 */
@Data
public class ModifyEmailVo {
    @Email
    String email;
    @Length(max = 6, min = 6)
    String code;
}
```

com/xiaoRed/controller/AuthorizeController.java
请求验证码的方法中，type多一个modify类型，表示修改邮箱
```java
    /**
     * 请求邮件验证码
     * @param type 类型， 必须是register或reset或modify中的一个
     * @param email 请求邮件，必须是合法的邮箱地址才能通过校验
     * @param request 请求，用来获得请求的ip地址
     * @return 是否请求成功
     */
    @GetMapping("/ask-code")
    public RestBean<Void> askVerifyCode(@RequestParam @Pattern(regexp = "(register|reset|modify)") String type, @RequestParam @Email String email,
                                        HttpServletRequest request){
        String message = accountService.sendEmailVerifyCode(type, email, request.getRemoteAddr());
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com/xiaoRed/listener/MailQueueListener.java
消息队列中，发送邮件的方法，新增修改邮箱功能对应的邮件内容
```java
    /**
     * 处理邮件发送
     * @param data 就是生产者发来的消息，包含邮件信息：类型，收件人，验证码
     */
    @RabbitHandler
    public void sendMailMessage(Map<String, Object> data){
        ...
        //不同的type，邮件内容不同
        SimpleMailMessage message = switch (data.get("type").toString()) {
            ...
            case "modify" ->
                    createMailMessage("您的邮箱修改邮件",
                            "您好，您正在绑定新的电子邮箱，验证码: "+code+"，有效时间3分钟，如非本人操作，请无视。",
                            email);
            default -> null;
        };
        if(message == null) return;
        sender.send(message);
    }
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 修改账号绑定的电子邮箱
     * @param id 账号对应的id
     * @param vo 前端传过来的新电子邮箱地址和验证码封装为vo
     * @return
     */
    @PostMapping("/modify-email")
    public RestBean<Void> modifyEmail(@RequestAttribute(Const.ATTR_USER_ID) int id, @RequestBody @Valid ModifyEmailVo vo){
        String message = accountService.modifyEmail(id, vo);
        return message==null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com/xiaoRed/service/impl/AccountServiceImpl.java
```java
    /**
     * 修改账户绑定的电子邮箱功能
     * @param id 执行此操作的账号id
     * @param vo 前端传来的新电子邮箱和验证码封装为vo
     * @return 返回null表示修改成功，修改失败则返回错误信息提示
     */
    @Override
    public String modifyEmail(int id, ModifyEmailVo vo){
        String code = stringRedisTemplate.opsForValue().get(Const.VERIFY_EMAIL_DATA + vo.getEmail()); //拿到redis中存的验证码
        if(code == null) return "请先获取验证码";
        if(!code.equals(vo.getCode())) return "验证码错误，请重新输入";
        Account account = findAccountByNameOrEmail(vo.getEmail());
        if(account!=null && account.getId() != id) return "此电子邮箱已被其他用户使用，请更换一个新的电子邮箱";
        boolean update = this.update()
                .set("email", vo.getEmail())
                .eq("id", id)
                .update();
        if (update){
            //更新数据库成功了，表明修改成功，对应的验证码没用了，手动从redis删除
            stringRedisTemplate.delete(Const.VERIFY_EMAIL_DATA + vo.getEmail());
        }
        return null;
    }
```

# 账号安全设置

## 隐私设置

### 需求及前置

>勾选一次checkbox就发一次请求，也就是一次只会改变一种隐私，不用多个隐私一起改【为了设计请求vo的简便】
和账号详细信息的情况一样，在第一次隐私设置之前，对应id在表中是没有数据的，这时展示隐私设置的情况时，采用的方案是：
直接向前端返回一个默认的隐私对象，而实际上数据表中还没有数据



隐私表
```sql
CREATE TABLE db_account_privacy  (
  `id` int NOT NULL,
  `email` tinyint(255) NULL,
  `gender` tinyint(255) NULL,
  `phone` tinyint(255) NULL,
  `qq` tinyint(255) NULL,
  `wx` tinyint(255) NULL,
  PRIMARY KEY (`id`)
);
```

使用easycode自动生成对应的entity，service，serviceimpl，mapper

AccountPrivacy提供默认值
```java
@Data
@TableName("db_account_privacy")
public class AccountPrivacy implements BaseData {
    @TableId(type = IdType.AUTO)
    final Integer id; //设置为final，表示构造时一定要有
    //0不开启，1开启。默认所有隐私都开启
    private boolean email = true;
    private boolean gender = true;
    private boolean phone = true;
    private boolean qq = true;
    private boolean wx = true;
}
```

com/xiaoRed/service/impl/AccountPrivacyServiceImpl.java
```java
    /**
     * 获得对应账号的隐私权限信息，如果数据库中没有对应的记录，则返回一个默认值（权限全开）
     * @param id
     * @return
     */
    @Override
    public AccountPrivacy getAccountPrivacy(int id){
        return Optional.ofNullable(this.getById(id)).orElse(new AccountPrivacy(id));
    }

```

### 展示隐私设置

com/xiaoRed/entity/vo/response/AccountPrivacyVo.java
响应给前端的隐私设置信息封装为一个vo
```java
/**
 * 响应给前端的隐私设置信息
 */
@Data
public class AccountPrivacyVo {
    private boolean email;
    private boolean gender;
    private boolean phone;
    private boolean qq;
    private boolean wx;
}
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 返回账号的隐私设置，展示在前端
     * @param id
     * @return
     */
    @GetMapping("/privacy")
    public RestBean<AccountPrivacyVo> privacy(@RequestAttribute(Const.ATTR_USER_ID) int id){
        AccountPrivacy accountPrivacy = privacyService.getAccountPrivacy(id);
        return RestBean.success(accountPrivacy.asViewObject(AccountPrivacyVo.class));
    }
```

com/xiaoRed/service/impl/AccountPrivacyServiceImpl.java
```java
    /**
     * 获得对应账号的隐私权限信息，如果数据库中没有对应的记录，则返回一个默认值（权限全开）
     * @param id
     * @return
     */
    @Override
    public AccountPrivacy getAccountPrivacy(int id){
        return Optional.ofNullable(this.getById(id)).orElse(new AccountPrivacy(id));
    }
```

### 保存隐私设置

com/xiaoRed/entity/vo/request/SavePrivacyVo.java
前端修改隐私设置传来的修改种类 + 是否开启封装为一个vo【一次只改一种隐私】
```java
/**
 * 前端修改隐私设置传来的修改种类 + 是否开启封装为一个vo【一次只改一种隐私】
 */
@Data
public class SavePrivacyVo {
    @Pattern(regexp = "email|gender|qq|wx|phone")
    String type;
    boolean status;
}
```


com/xiaoRed/controller/AccountController.java
```java
    /**
     * 保存隐私设置
     * @param id
     * @param vo
     * @return
     */
    @PostMapping("/save-privacy")
    public RestBean<Void> savePrivacy(@RequestAttribute(Const.ATTR_USER_ID) int id, SavePrivacyVo vo){
        privacyService.savePrivacy(id, vo);
        return RestBean.success();
    }
```

com/xiaoRed/service/impl/AccountPrivacyServiceImpl.java
```java
     /**
     * 保存隐私设置：一次只能修改一中隐私
     * @param id
     * @param vo 前端传来的隐私种类 + 是否公开 分装为一个vo
     */
    @Override
    @Transactional
    public void savePrivacy(int id, SavePrivacyVo vo){
        //从数据库查找对应的隐私，如果没有记录，返回默认的隐私对象【权限全开】
        AccountPrivacy privacy = Optional.ofNullable(this.getById(id)).orElse(new AccountPrivacy(id));
        //按照这次传来的隐私种类，修改对应的隐私
        boolean status = vo.isStatus();
        switch (vo.getType()){
            case "phone" -> privacy.setPhone(status);
            case "qq" -> privacy.setQq(status);
            case "wx" -> privacy.setWx(status);
            case "gender" -> privacy.setGender(status);
            case "email" -> privacy.setEmail(status);
        }
        //把改好的隐私再存回数据库
        this.saveOrUpdate(privacy);
    }
```

## 重置密码

>和忘记密码的重置密码功能有相似的地方，但略有不同
这个重置密码是在登录成功状态下完成的，所以逻辑有点不一样

com/xiaoRed/entity/vo/request/ChangePawVo.java
前端传来的原密码，新密码封装为vo
```java
/**
 * 修改密码功能：前端传来的原密码，新密码封装为vo
 */
@Data
public class ChangePawVo {
    @Length(min = 5, max = 20)
    String password_new;
    @Length(min = 5, max = 20)
    String password_old;
}
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 修改密码功能【与忘记密码的重置密码区分】
     * @param id 账号id
     * @param vo 前端传来的原密码，新密码封装为vo
     * @return
     */
    @PostMapping("/change-password")
    public RestBean<Void> changePassword(@RequestAttribute(Const.ATTR_USER_ID) int id, @RequestBody @Valid ChangePawVo vo){
        String message = accountService.changePassword(id, vo);
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com/xiaoRed/service/impl/AccountServiceImpl.java
```java
    /**
     * 修改密码功能【和忘记密码的重置密码功能区分】
     * @param id 账号id
     * @param vo 前端传来的原密码，新密码封装为vo
     * @return 返回null说明修改成功，否则返回错误信息提示
     */
    @Override
    public String changePassword(int id, ChangePawVo vo){
        Account account = findAccountById(id);
        String password_db = account.getPassword(); //拿到数据库中存储的密码
        if (!encoder.matches(vo.getPassword_old(), password_db)) return "原密码不正确，重置密码失败"; //如果原密码匹配不上，则修改失败
        //将新密码加密存储到数据库中
        boolean isSuccess = this.update()
                .eq("id", id)
                .set("password", encoder.encode(vo.getPassword_new()))
                .update();
        return isSuccess ? null : "未知错误，请联系管理员";
    }
```

# 头像操作

>使用Minio对象存储来存放项目中的头像图片

导入Minio依赖
```xml
<!--    Minio对象存储依赖    -->
        <dependency>
            <groupId>io.minio</groupId>
            <artifactId>minio</artifactId>
            <version>8.3.9</version>
        </dependency>
```

docker开启minio容器

## 上传头像

对应的表添加`avatar`字段，存放图片的url，代码中的相关类也要进行修改

com/xiaoRed/controller/ImageController.java
专门用于处理图片的controller
```java
/**
 * 专门用于处理图片的controller
 */
@Slf4j
@RestController
@RequestMapping("/api/image")
public class ImageController {

    @Resource
    ImageService imageService;

    /**
     * 上传头像功能：利用minio客户端，将头像传到minio服务器存储，数据库中只需要存储这个头像的url即可
     * @param file 上传的头像文件
     * @param id
     * @return
     * @throws IOException
     */
    @PostMapping("/avatar")
    public RestBean<String> uploadAvatar(@RequestParam("file")MultipartFile file,
                                         @RequestAttribute(Const.ATTR_USER_ID) int id)throws IOException {
        if (file.getSize() > 1025*100)
            return RestBean.failure(400, "头像图片不能大于100KB");
        log.info("正在进行头像上传操作...");
        String url = imageService.uploadAvatar(file, id);
        if(url!=null){
            log.info("头像上传成功，大小为：" + file.getSize());
            return RestBean.success(url);
        }else{
            return RestBean.failure(40, "头像上传失败，请联系管理员!");
        }
    }
}
```

application.yml
```yml
  minio:
    endpoint: 'http://localhost:9000'
    username: 'minio'
    password: 'password'
```

com/xiaoRed/config/MinioConfiguration.java
配置Minio客户端
```java
/**
 * 配置Minio客户端
 */
@Slf4j
@Configuration
public class MinioConfiguration {

    @Value("${spring.minio.endpoint}")
    String endpoint;
    @Value("${spring.minio.username}")
    String username;
    @Value("${spring.minio.password}")
    String password;

    @Bean
    public MinioClient minioClient(){
        log.info("Init Minio Client...");
        return MinioClient.builder()
                .endpoint(endpoint)
                .credentials(username, password)
                .build();

    }
}
```

com/xiaoRed/service/impl/ImageServiceImpl.java
图片名不要直接设置为上传者的id，而是用随机的uuid
1、使用浏览器本地缓存，如果采用上传者的id，那么图片被修改，不会加载新的图片
2、反爬虫
```java
@Slf4j
@Service
public class ImageServiceImpl implements ImageService {

    @Resource
    MinioClient minioClient;

    @Resource
    AccountMapper accountMapper;

    /**
     * minio客户端将头像上传到minio服务端
     * 图片名不要直接设置为上传者的id，而是用随机的uuid
        1、使用浏览器本地缓存，如果采用上传者的id，那么图片被修改，不会加载新的图片
        2、反爬虫
     * @param file 要上传的头像文件
     * @param id
     * @return 上传成功，返回url，失败返回null
     * @throws IOException
     */
    @Override
    public String uploadAvatar(MultipartFile file, int id) throws IOException {
        String imageName = UUID.randomUUID().toString().replace("-", ""); //先用uuid随机给文件起个名
        imageName = "/avatar/" + imageName; //加个目录前缀,表示将图片存放在avatar目录下
        //设置上传参数
        PutObjectArgs args = PutObjectArgs.builder()
                .bucket("forum") //上传到forum存储桶
                .stream(file.getInputStream(), file.getSize(), -1) //分块大小默认
                .object(imageName) //存储名字
                .build();
        try{ //成功上传
            minioClient.putObject(args); //利用minio客户端以及设置好的参数进行上传
            if(accountMapper.update(null, Wrappers.<Account>update().eq("id", id).set("avatar", imageName))>0)
                return imageName;
            else return null;
        }catch(Exception e){ //上传出现异常
            log.error("图片上传失败：" + e.getMessage(), e);
            return null;
        }
    }
}
```

## 获取并展示头像

com/xiaoRed/controller/ObjectController.java
```java
@Slf4j
@RestController
public class ObjectController {

    @Resource
    ImageService imageService;

    /**
     * 获取头像
     * @param request
     * @param response
     * @throws Exception
     */
    @GetMapping("/images/avatar/**")
    public void avatarFetch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        this.fetchImage(request, response);
    }

    /**
     * 这个私有方法作为获取各种类型图片的统一接口
     * 设置响应头：缓存周期设置为1个月，这样的话，1月内，浏览器获取该图片都不用再向后端请求，直接从本地缓存里拿，优化性能。
     * @param request
     * @param response
     * @throws IOException
     */
    private void fetchImage(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String imagePath = request.getServletPath().substring(7); //minio存储的路径没有“/images”，将它去掉
        ServletOutputStream stream = response.getOutputStream();
        //路径长度小于13的一看就不对，直接报错就行
        if(imagePath.length()<=13){
            stream.println(RestBean.failure(404, "Not found").toString());
        }else{
            try{
                imageService.fetchImageFromMinio(stream, imagePath);
                //设置响应头：缓存周期设置为1个月，这样的话，1月内，浏览器获取该图片都不用再向后端请求，直接从本地缓存里拿，优化性能。
                response.setHeader("Cache-Control", "max-age-259200"); //缓存周期：1个月
            }catch(ErrorResponseException e){//注意这个异常时minio里的异常
                if(e.response().code()==404){//minio响应404，说明没有存储该图片
                    response.setStatus(404);
                    stream.println(RestBean.failure(404, "Not found").toString());
                }else{ //如果不是404，说明是其他问题，打印个日志
                    log.error("从Minio服务器获取图片出现异常：" + e.getMessage(), e);
                }
            }
        }
    }
}
```

com/xiaoRed/config/SecurityConfiguration.java
实际上，这些图片相关的属于静态资源，可以全部进行放行
```java
.requestMatchers("/images/**").permitAll()
```

com/xiaoRed/service/impl/ImageServiceImpl.java
```java
    /**
     * 从Minio服务器获取图片
     * @param outputStream
     * @param image 图片路径
     */
    @Override
    public void fetchImageFromMinio(OutputStream outputStream, String image) throws Exception {
        //设置获取参数
        GetObjectArgs args = GetObjectArgs.builder()
                .bucket("forum")
                .object(image)
                .build();
        GetObjectResponse response = minioClient.getObject(args); //这个response是一个输入流
        //将获取到图片的这个输入流拷贝到输出流
        IOUtils.copy(response, outputStream);
    }
}
```

## 测试

上传头像调用`POST http://localhost:8080/api/image/avatar`

访问Minio服务器http://localhost:9090，发现在forum桶下，创建出了一个avatar目录，目录中存放了一个名为28169c289a1e499b8a8ebcacf7254805的图片，即刚刚上传的那张

前端头像处也成功展示了这个头像，展示时调用`localhost:8080/images/avatar/28169c289a1e499b8a8ebcacf7254805`

数据库中avatar字段是`/avatar/28169c289a1e499b8a8ebcacf7254805`

# 对接天气API

本项目使用`和风天气`提供的api接口，获得城市信息，天气信息
官网：https://dev.qweather.com/docs/api/

在阅读开发文档时，最关键的就是查看各个功能的**请求URL**，**请求参数**，**返回数据的格式**(看样例)和一些**特殊要求**(比如这里的返回数据会在JSON格式上进行Gzip压缩)

***

com/xiaoRed/controller/ForumController.java
```java
/**
 * 论坛主体功能相关的controller
 */
@RestController
@RequestMapping("/api/forum")
public class ForumController {

    @Resource
    WeatherService weatherService;

    /**
     * 获取天气信息，包括实时天气和未来5小时的天气预报
     * @param longitude 经度
     * @param latitude 维度
     * @return
     */
    @GetMapping("/weather")
    public RestBean<WeatherVo> weather(double longitude, double latitude){
        WeatherVo vo = weatherService.fetchWeather(longitude, latitude);
        return vo == null ? RestBean.failure(400, "获取地理位置信息与天气失败，请联系管理员！") : RestBean.success(vo);
    }
}
```

com/xiaoRed/entity/vo/response/WeatherVo.java
查看开发文档，api接口返回的数据都是JSON格式的，里面有很多结构，为了方便，这里不做提取，直接把整个JSON数据存取过来响应给前端，由前端在使用时自行提取要哪些部分。
```java
/**
 * 响应给前端的天气信息
 */
@Data
public class WeatherVo {
    JSONObject location; //位置信息
    JSONObject now_weather; //实时天气
    JSONArray hourly; //天气预报
}
```

阅读文档后发现，所有的请求url都要携带一个用于开发的key，这里去它那里申请一个免费版本的，然后存到application.yaml中，方便后续使用
```yaml
spring:
  ...
  weather:
    key: bfb85c44776447ed928c53588c4641b0
```

com/xiaoRed/config/WebConfiguration.java
通过请求“和风天气”给的url地址来获得数据，实际上就是要发送Restful请求。这里在WebConfiguration中注册一个SpringBoot提供的专门用于发送Rest请求的类，方便后续代码编写
```java
//这个RestTemplate可以方便地发送Rest请求
@Bean
public RestTemplate restTemplate(){
        return new RestTemplate();
}
```

com/xiaoRed/service/impl/WeatherServiceImpl.java
思路在注释中写的很清晰了
```java
@Service
public class WeatherServiceImpl implements WeatherService {

    //这个RestTemplate可以方便地发送Rest请求
    @Resource
    RestTemplate restTemplate;

    @Resource
    StringRedisTemplate stringRedisTemplate;

    //用于“和风天气”api开发的用户认证key
    @Value("${spring.weather.key}")
    String key;

    /**
     *
     * @param longitude 经度
     * @param latitude 纬度
     * @return
     */
    @Override
    public WeatherVo fetchWeather(double longitude, double latitude){
        return fetchFromCache(longitude, latitude);
    }

    /**
     * 同一地区，一个小时内的天气变化一般不大，因此可以做缓存，减少对api接口的调用(省着点免费次数)，也起到了一定的防刷保护作用
     * 1、通过经纬度，调用城市搜索api，拿到响应数据，提取出地区id
     * 2、以地区id为key去redis里找，如果找得到，直接将天气信息返回
     * 3、如果缓存里没有，只能老老实实调用获取天气信息的api，拿到数据后，先存入redis做缓存，再返回
     * @param longitude 经度
     * @param latitude 纬度
     * @return
     */

    private WeatherVo fetchFromCache(double longitude, double latitude){
        //先通过经纬度，拿到此次请求的地区id
        //涉及到“和风天气”的城市搜索api，文档地址：https://dev.qweather.com/docs/api/geoapi/city-lookup/
        byte[] data = restTemplate.getForObject(
                "https://geoapi.qweather.com/v2/city/lookup?location="+longitude+","+latitude+"&key="+key,byte[].class);
        JSONObject geo = this.decompressStringToJson(data);
        if(geo==null)return null;
        JSONObject location = geo.getJSONArray("location").getJSONObject(0); //将相应数据中的location字段拿出来
        int id = location.getInteger("id"); //拿到地区id

        //然后尝试从缓存中取，看此次请求的地区有没有在缓存里
        String key = "weather:" + id;
        String cache = stringRedisTemplate.opsForValue().get(key);
        if(cache!=null) //如果此次请求的地区在缓存里，那就把缓存数据转换为WeatherVo，然后直接返回
            return JSONObject.parseObject(cache).to(WeatherVo.class);
        //如果缓存中没有此次请求地区的天气信息，那就只能去请求一次获取天气信息的api
        WeatherVo vo = this.fetchFromAPI(id, location);
        if(vo == null)return null;
        //拿到地区的天气信息，存入redis缓存，设置1小时过期时间
        stringRedisTemplate.opsForValue().set(key, JSONObject.from(vo).toJSONString(), 1, TimeUnit.HOURS);
        return vo;
    }

    /**
     * 获取实时天气和未来5小时的天气预报
     * @param id 地区id
     * @param location 为了封装WeatherVo的字段
     * @return
     */

    private WeatherVo fetchFromAPI(int id, JSONObject location){
        WeatherVo vo = new WeatherVo();
        vo.setLocation(location);
        //涉及到“和风天气”的实时天气api，文档地址：https://dev.qweather.com/docs/api/weather/weather-now/，这里使用的是免费的那个请求地址
        JSONObject now = this.decompressStringToJson(restTemplate.getForObject(
                "https://devapi.qweather.com/v7/weather/now?location="+id+"&key="+key, byte[].class));
        if(now == null) return null;
        //vo.setNow(now.getJSONObject("now"));
        vo.setNow_weather(now.getJSONObject("now"));

        //涉及到“和风天气”的逐小时天气预报api，文档地址：https://dev.qweather.com/docs/api/weather/weather-hourly-forecast/，这里使用的是免费的那个请求地址
        JSONObject hourly = this.decompressStringToJson(restTemplate.getForObject(
                "https://devapi.qweather.com/v7/weather/24h?location="+id+"&key="+key, byte[].class));
        if(hourly == null) return null;
        //请求获得的是未来24小时的天气预报，项目中只用未来5小时，因此这里做个限制，只拿前5个
        vo.setHourly(new JSONArray(hourly.getJSONArray("hourly").stream().limit(5).toList()));
        return vo;
    }

    /**
     * 解压拿到的响应数据
     * 文档中有提到，请求返回的数据是JSON格式，在这前提下进行了Gzip压缩。因此要真正拿到这里面的JSON数据，要先进行解压
     * @param data 拿到的被Gzip压缩的响应数据
     * @return 解压后的JSON格式的数据
     */
    private JSONObject decompressStringToJson(byte[] data){
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        try {
            GZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(data));
            byte[] buffer = new byte[1024]; //作为输入流和输出流的传输媒介
            int read;
            while((read = gzip.read(buffer)) != -1) //把gzip中的数据读到buffer，直到读完为止
                outputStream.write(buffer, 0, read); //把buffer中的数据(已被解压)写入到这个输出流
            gzip.close();
            outputStream.close();
            return JSONObject.parseObject(outputStream.toString()); //转换为JSON text的形式
        }catch(IOException e){
            return null;
        }
    }

}
```

# 发表帖子

## 上传图片

**功能需求**
>编写文章时，难免会用到图片，如何上传，展示图片是一个十分考究的问题。

**实现思路**
如果直接将图片的base64编码存到数据库中，会非常大，对服务器造成较高的压力
这里可以采用之前上传头像类似的做法，使用minio对象存储
* 文章图片不做永久存储，只是一个缓存，比如1年后就全删掉，看不了了。给文章图片一个统一的/cache目录
* 本地上传/粘贴图片，都会将图片自动上传到minio
* 可以再划分得细一点，加上上传日期，同一天上传的图片放在一起，方便后期管理
* 对这个上传图片接口限流【尚未完成】

***

**实现**

首先给这些文章中的图片创一个表，包含：谁上传，图片名，什么时候上传
```sql
CREATE TABLE `db_image_store` (
  `uid` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `upload_time` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

然后用easycode自动构建出这个表的entity，mapper，service，serviceimpl

com/xiaoRed/controller/ImageController.java
```java
    /**
     * 编辑帖子时候的上传图片功能
     * 在编写文章添加图片时，会把图片先上传到minio【这个方法的任务】，然后再从minio中获取下来展示【ObjectController的任务】
     * @param file 上传的图片
     * @param id
     * @return
     * @throws IOException
     */
    @PostMapping("/cache")
    public RestBean<String> uploadImage(@RequestParam("file")MultipartFile file,
                                         @RequestAttribute(Const.ATTR_USER_ID) int id)throws IOException {
        if (file.getSize() > 1024*1024*5)
            return RestBean.failure(400, "上传图片不能大于5MB");
        log.info("正在进行图片上传操作...");
        String url = imageService.uploadImage(file, id);
        if(url!=null){
            log.info("图片上传成功，大小为：" + file.getSize());
            return RestBean.success(url);
        }else{
            return RestBean.failure(40, "图片上传失败，请联系管理员!");
        }
    }
```

com/xiaoRed/service/impl/ImageServiceImpl.java
```java
    @Resource
    ImageStoreService imageStoreService;

    private SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");

@Override
    public String uploadImage(MultipartFile file, int id) throws IOException {
        //todo:限制请求频率


        String imageName = UUID.randomUUID().toString().replace("-", ""); //先用uuid随机给文件起个名
        Date date = new Date();
        imageName = "/cache/" + format.format(date) + "/" + imageName; //加个目录前缀,表示将图片存放在cache目录下,并且按日期分类存储，方便后续管理
        //设置上传参数
        PutObjectArgs args = PutObjectArgs.builder()
                .bucket("forum") //上传到forum存储桶
                .stream(file.getInputStream(), file.getSize(), -1) //分块大小默认
                .object(imageName) //存储名字
                .build();
        try{ //成功上传
            minioClient.putObject(args); //利用minio客户端以及设置好的参数进行上传
            if (imageStoreService.save(new ImageStore(id, imageName, date))){
                return imageName;
            }else{
                return null;
            }
        }catch(Exception e){ //上传出现异常
            log.error("图片上传失败：" + e.getMessage(), e);
            return null;
        }
    }
```

***
**测试**

往富文本编辑器粘贴图片，弹出提示“图片上传成功”
然后去minio服务器那里查看，可以看到在forum桶中，多出了一个cache目录，目录有一个20231014子目录(上传的时间是2023年10月14日)，里面有一张刚刚上传的名为`3f3f3b394e36440a9ea030d41b6dd2f6`的图片

上述流程，发送的是`http://localhost:8080/api/image/cache`请求，返回的响应数据是

```json
code: 200
data: "/cache/20231014/3f3f3b394e36440a9ea030d41b6dd2f6"
message: "请求成功"
```

## 获取图片

之前的ObjectController已经把从minio获取图片的功能写好了，只是之前只有头像，现在不分类了，啥图片都统一获取就行

com/xiaoRed/controller/ObjectController.java
就是改了个方法名，接口地址改一下，使其更有普遍性，连代码内容都没变
```java
@Slf4j
@RestController
public class ObjectController {

    @Resource
    ImageService imageService;

    /**
     * 获取图片，包括头像，文章图片...
     * @param request
     * @param response
     * @throws Exception
     */
    @GetMapping("/images/**")
    public void imageFetch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        response.setHeader("Content-type", "image/jpg"); //如果有人想复制图片地址，额外访问时，需要加上这个，才可以正常访问
        this.fetchImage(request, response);
    }

    /**
     * 这个私有方法作为获取各种类型图片的统一接口
     * 设置响应头：缓存周期设置为1个月，这样的话，1月内，浏览器获取该图片都不用再向后端请求，直接从本地缓存里拿，优化性能。
     * @param request
     * @param response
     * @throws IOException
     */
    private void fetchImage(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String imagePath = request.getServletPath().substring(7); //minio存储的路径没有“/images”，将它去掉
        ServletOutputStream stream = response.getOutputStream();
        //路径长度小于13的一看就不对，直接报错就行
        if(imagePath.length()<=13){
            stream.println(RestBean.failure(404, "Not found").toString());
        }else{
            try{
                imageService.fetchImageFromMinio(stream, imagePath);
                //设置响应头：缓存周期设置为1个月，这样的话，1月内，浏览器获取该图片都不用再向后端请求，直接从本地缓存里拿，优化性能。
                response.setHeader("Cache-Control", "max-age-259200"); //缓存周期：1个月
            }catch(ErrorResponseException e){//注意这个异常时minio里的异常
                if(e.response().code()==404){//minio响应404，说明没有存储该图片
                    response.setStatus(404);
                    stream.println(RestBean.failure(404, "Not found").toString());
                }else{ //如果不是404，说明是其他问题，打印个日志
                    log.error("从Minio服务器获取图片出现异常：" + e.getMessage(), e);
                }
            }
        }
    }
}
```

***
**测试**
继续上一章上传图片的测试
粘贴图片到富文本编辑器，上传成功后，就能直接看到了

请求地址是：http://localhost:8080/images/cache/20231014/3f3f3b394e36440a9ea030d41b6dd2f6

## 加载帖子类型

>前端页面加载后，需要向后端拉取可以选择的帖子类型有哪些

帖子类型专门用`db_topic_type`表来存储
```sql
CREATE TABLE `db_topic_type` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `desc` varchar(255) DEFAULT NULL,
  `color` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

用easycode生成这个表得entity和mapper即可
com/xiaoRed/entity/dto/TopicType.java
继承BaseData，方便转换为vo
```java
@SuppressWarnings("serial")
@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("db_topic_type")
public class TopicType implements BaseData {
    @TableId
    private Integer id;

    private String name;
    @TableField(value = "`desc`")
    private String desc;
    
    private String color;
}
```

com/xiaoRed/entity/vo/TopicTypeVo.java
```java
/**
 * 向前端返回帖子类型的一切信息
 */
@Data
public class TopicTypeVo {
    private Integer id;

    private String name;

    private String desc;

    private String color;
}
```

com/xiaoRed/controller/ForumController.java
```java
    /**
     * 返回所有帖子类型的id，类型名，描述，颜色。即de_topic_type表中的数据
     * @return
     */
    @GetMapping("/types")
    public RestBean<List<TopicTypeVo>> listTypes(){
        return RestBean.success(topicService.listTypes()
                .stream()
                .map(topicType -> topicType.asViewObject(TopicTypeVo.class))
                .toList());
    }
```

com/xiaoRed/service/TopicService.java
```java
public interface TopicService{
    List<TopicType> listTypes();
}
```

com/xiaoRed/service/impl/TopicServiceImpl.java
```java
@Service
public class TopicServiceImpl implements TopicService {

    @Resource
    TopicTypeMapper topicTypeMapper;

    /**
     * 返回所有帖子类型的id，类型名，描述，颜色。即de_topic_type表中的数据
     * @return
     */
    @Override
    public List<TopicType> listTypes() {
        return topicTypeMapper.selectList(null);
    }
}
```

## 帖子发表

### 需求分析

前端在富文本编辑器中，选择好帖子类型，编辑好标题，内容后，即可发表帖子

一个帖子需要包含：帖子id，帖子类型id，标题，内容，作者id，创建时间
其他字段都比较简单，这里主要分析一下`内容`字段的处理

在前端，为了避免xss攻击，富文本编辑器采用`delta`模式，文章内容以JSON格式存储。比如以下文本
```
演示一下，下面是一种截图
**截图**
```
前端将富文本编辑器的内容绑定到article的text字段，console.log(article.text)
不看其他没啥用的字段，就看文本存在哪
```json
{"ops":[{"insert":"演示一下，下面是一张截图\n"},{"attributes":{"width":"557"},"insert":{"image":"http://localhost:8080/images/cache/20231020/788afd6cfc214aada42cedca0399be7c"}}]}
```

本项目的前端会将这个json数据全部传给后端，可以看到，真正的文本内容其实是在ops这个JSON数组里的insert字段下。图片在insert字段下的image字段中，附加上它的url地址。
后端的做法是将整个JSON数据转换为字符串后，直接存到数据库中，而以后用到文章内容(比如帖子列表的预览，查看帖子详情...)时，需要做一下转换，提取出insert字段中的内容即可

除此之外，后端还需要对前端的请求做校验
* 限流，避免高频地创建帖子(还没实现)
* 校验帖子文本长度是否超出限制
* 校验帖子类型id是否在正确的取值范围内

### 具体实现

创建db_topic表存储帖子，由于文章内容可能比较长，`content`字段采用text类型
```sql
CREATE TABLE `db_topic` (
  `id` int(11) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `content` text,
  `uid` int(11) DEFAULT NULL,
  `type` int(255) DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

用easycode生成db_topic的entity，mapper

TopicService和TopicServiceImpl做出以下修改，提供对Topic的mybatis-plus支持
```java
public interface TopicService extends IService<Topic>

public class TopicServiceImpl extends ServiceImpl<TopicMapper, Topic> implements TopicService
```

com/xiaoRed/controller/ForumController.java
```java
    /**
     * 发表帖子功能
     * @param vo 前端发送来的发表帖子参数包装为一个TopicCreateVo对象
     * @param uid 帖子作者的id，直接从缓存里拿
     */
    @PostMapping("/create-topic")
    public  RestBean<Void> createTopic(@Valid @RequestBody TopicCreateVo vo,
                                       @RequestAttribute(Const.ATTR_USER_ID) int uid){
        String message = topicService.createTopic(uid, vo);
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com/xiaoRed/entity/vo/request/TopicCreateVo.java
```java
/**
 * 前端发送来的发表帖子参数包装为一个TopicCreateVo对象
 */
@Data
public class TopicCreateVo {
    @Min(1)
    @Max(5)
    int type; //到service会再进行次校验
    @Length(min = 1, max = 20)
    String title;
    //前端富文本采用delta模式，文本内容是JSON格式的，真正的文本存储在ops这个JSON数组中的insert字段里
    JSONObject content; 
}
```

com/xiaoRed/service/impl/TopicServiceImpl.java
```java
    //service调用之前就先获取到所有帖子类型的id，方便后续的校验工作（比如createTopic方法，校验类型id是否合法）
    private Set<Integer> types = null;
    @PostConstruct
    private void initTypes(){
        types = this.listTypes()
                .stream()
                .map(TopicType::getId)
                .collect(Collectors.toSet());
    }

    /**
     * 发表帖子功能
     * 前置工作：对帖子类型id，长度做校验，并对请求做限流，限制发文频率
     * @param uid 帖子作者的id
     * @param vo 前端发送来的发表帖子参数包装为一个TopicCreateVo对象
     * @return 返回空表示创建成功，否则返回错误提示
     */
    @Override
    public String createTopic(int uid, TopicCreateVo vo){
        //验证帖子长度是否超出文章长度限制
        if(!contentLimitCheck(vo.getContent()))
            return "文章内容超出长度限制，发文失败！";
        //验证文章类型(用户正常操作肯定不会有问题的，因此触发这种情况的，一般都是故意来搞攻击的)
        if(!types.contains(vo.getType()))
            return "文章类型非法，发文失败";
        //todo:限制发文频率


        Topic topic = new Topic();
        BeanUtils.copyProperties(vo, topic); //将vo的属性拷贝给topic对应的同名属性
        topic.setContent(vo.getContent().toJSONString()); //content要先把json格式转换为字符串
        topic.setUid(uid);
        topic.setTime(new Date());
        if(this.save(topic)){
            return null;
        }else{
            return "内部错误，请联系管理员";
        }
    }

    /**
     * 校验帖子长度是否超出限制
     * @param content 前端发送过来的帖子内容，其实帖子真正的文本存储在ops这个JSON数组下的insert字段
     * @return 返回true表示通过校验，返回false表示超出长度限制，校验不通过
     */
    private boolean contentLimitCheck(JSONObject content){
        if(content==null) return false;
        long length = 0;
        for(Object op : content.getJSONArray("ops")){ //取出ops这个JSON数组
            length += JSONObject.from(op).getString("insert").length(); //从这个数组中拿到insert字段的内容，记录长度
            if(length>20000) return false;
        }
        return true;
    }
```

### 测试

帖子类型选择`日常闲聊`，帖子标题是“帖子功能测试”
发表帖子内容如下：
```
这是一篇关于帖子功能测试的文章
测试的内容如下：
1）帖子是否能正常发表
2）不符合规定的文章是否会被识别出来，并且中止其发表
3）测试一下上传图片功能是否能正常使用
**截图**

```

打印下后端接收到的TopicCreateVo对象
```
TopicCreateVo(type=1, title=帖子功能测试, {"ops":[{"insert":"这是一篇关于帖子功能测试的文章\n测试的内容如下：\n1）帖子是否能正常发表\n2）不符合规定的文章是否会被识别出来，并且中止其发表\n3）测试一下上传图片功能是否能正常使用\n"},{"attributes":{"width":"557"},"insert":{"image":"http://localhost:8080/images/cache/20231020/788afd6cfc214aada42cedca0399be7c"}},{"insert":"\n"}]})
```

数据库中，对应记录的content字段
```
{"ops":[{"insert":"这是一篇关于帖子功能测试的文章\n测试的内容如下：\n1）帖子是否能正常发表\n2）不符合规定的文章是否会被识别出来，并且中止其发表\n3）测试一下上传图片功能是否能正常使用\n"},{"attributes":{"width":"557"},"insert":{"image":"http://localhost:8080/images/cache/20231020/788afd6cfc214aada42cedca0399be7c"}},{"insert":"\n"}]}
```

# CacheUtil

这个项目许多地方要用到redis缓存，可以将缓存的一些常用操作封装为一个工具类，方便后面使用

com/xiaoRed/utils/CacheUtil.java
```java
/**
 * 缓存工具类：封装常用的缓存操作
 */
@Component
public class CacheUtil {
    @Resource
    StringRedisTemplate template;

    //从缓存中取key对应的value，这个value是单个值
    public <T> T takeFromCache(String key, Class<T> dataType){
        String s = template.opsForValue().get(key);
        if(s == null) return null;
        return JSONObject.parseObject(s).to(dataType);
    }

    //从缓存中取key对应的value，这个value是个列表
    public <T> List<T> takeListFromCache(String key, Class<T> itemType){
        String s = template.opsForValue().get(key);
        if(s == null) return null;
        return JSONArray.parseArray(s).toList(itemType);
    }

    //向缓存中存入一个键值对，其中value是单个值
    public <T> void saveToCache(String key, T data, long expire){
        template.opsForValue().set(key, JSONObject.from(data).toJSONString(), expire, TimeUnit.SECONDS);
    }

    //向缓存中存入一个键值对，其中value是一个列表
    public <T> void saveListToCache(String key, List<T> list, long expire){
        template.opsForValue().set(key, JSONArray.from(list).toJSONString(), expire, TimeUnit.SECONDS);
    }

    //手动使缓存失效
    public void deleteCache(String key){
        template.delete(key);
    }

    //手动使缓存失效【多个key】
    public void deleteCachePattern(String key){
        Set<String> keys = Optional.ofNullable(template.keys(key)).orElse(Collections.emptySet());
        template.delete(keys);
    }
}
```

# 展示帖子列表

**需求分析**
* 展示内容：作者，头像，创建时间，帖子类型，标题，内容(前300字符)，图片
* 可以选择展示第几页，选定展示的帖子类型
* 设计为每页10个帖子，滚到最下面会继续展示后续的帖子(滚动加载)
一页5~10个帖子
* 由于这是首页，访问量比较大，因此需要对查询到的帖子列表做缓存
* 存在缓存三大问题，这里就不优化了
* 定时发布帖子：将发帖时间设置为未来的某个时间，查询帖子列表时，将查询的时间限制在当前时间之前【尚未实现】

***

## 版本一

**具体实现**

com/xiaoRed/controller/ForumController.java
```java
    /**
     * 根据选定查第几页和选定的帖子类型展示帖子列表
     * @param page 展示的是第几页
     * @param type 展示的帖子类型，全选则为0
     */
    @GetMapping("/list-topic")
    public RestBean<List<TopicPreviewVo>> listTopic(@RequestParam @Min(0) int page,
                                              @RequestParam @Min(0) int type){
        return RestBean.success(topicService.listTopicByPage(page, type));
    }
```

com/xiaoRed/entity/vo/response/TopicPreviewVo.java
```java
/**
 * 帖子列表中，每一个展示的帖子需要的属性封装为一个vo
 */
@Data
public class TopicPreviewVo {
    int id;
    int type;
    String title;
    String text;
    List<String> images;
    Date time;
    Integer uid;
    String username;
    String avatar;
}
```

Topic类添加`username`和`avatart`属性
```java
private String username;
private String avatar;
```

com/xiaoRed/mapper/TopicMapper.java
```java
    /**
     * 从所有帖子的第start个开始，获取10个帖子
     * @param start 从查询结果的第start个开始，一共查10条数据【实际上就是1页展示10个帖子】
     */
    @Select("select * from db_topic left join db_account on uid = db_account.id " +
            "order by `time` desc limit ${start}, 10")
    List<Topic> topicList(int start);

    /**
     * 在type类型的帖子中，从第start条数据开始，获取10个帖子
     * @param start 从查询结果的第start条数据开始，一共查10条数据【实际上就是1页展示10个帖子】
     * @param type 帖子类型
     */
    @Select("select * from db_topic left join db_account on uid = db_account.id " +
            "where type = #{type} " +
            "order by `time` desc limit ${start}, 10")
    List<Topic> topicListByType(int start, int type);
```

com/xiaoRed/constants/Const.java
添加展示列表的缓存key的前缀常量
```java
public final static String FORUM_TOPIC_PREVIEW_CACHE = "topic:preview:";
```

com/xiaoRed/service/impl/TopicServiceImpl.java
```java
@Resource
CacheUtil cacheUtil;

    /**
     * 根据选定查第几页和选定的帖子类型展示帖子列表
     * topicList(page*10)和topicListByType(page*10, type)的start都是page*10，其实就是一页展示10个帖子
     * 展示的是第0页，则是查询到的数据的0~9条；展示的是第1页，则是查询到的数据的10~19条...
     * @param page 展示的是第几页
     * @param type 展示的帖子类型，全选则为0
     */
    @Override
    public List<TopicPreviewVo> listTopicByPage(int page, int type){
        String key = Const.FORUM_TOPIC_PREVIEW_CACHE + page + ":" + type;
        List<TopicPreviewVo> previewVoList = cacheUtil.takeListFromCache(key, TopicPreviewVo.class); //先去缓存里拿
        if (previewVoList != null) return previewVoList; //从缓存中取到，就不用再去数据库里请求了

        List<Topic> topics;
        if(type == 0)
            topics = baseMapper.topicList(page*10);
        else
            topics = baseMapper.topicListByType(page*10, type);
        if(topics.isEmpty()) return null;
        previewVoList = topics.stream().map(this::resolveToPreview).toList(); //转化为TopicPreviewVo的列表
        cacheUtil.saveListToCache(key, previewVoList, 60); //拿到要求的帖子列表后，先存到缓存中
        return previewVoList;
    }

    /**
     * 将Topic类型的对象转换为TopicPreviewVo类型的对象
     * 同名属性可以直接bean拷贝
     * 主要就是TopicPreviewVo的text属性和images属性
     * 帖子文本存储在Topic的Content属性的ops数组中的insert字段里，由于只是展示在列表中，只展示前300个字符即可
     * 图片存储在Topic的Content属性的ops数组中的insert字段下的image字段里
     */
    private TopicPreviewVo resolveToPreview(Topic topic){
        TopicPreviewVo vo = new TopicPreviewVo();
        BeanUtils.copyProperties(topic, vo); //先把topic中的同名属性复制给vo
        List<String> images = new ArrayList<>();
        StringBuilder previewText = new StringBuilder();
        JSONArray ops = JSONObject.parseObject(topic.getContent()).getJSONArray("ops"); //先拿到ops数组
        for(Object ob : ops){
            Object insert = JSONObject.from(ob).get("insert");
            if(insert instanceof String text){ //如果insert里直接就是文本，那其实就是帖子内容
                if(previewText.length()>=300)continue;
                previewText.append(text);
            }else if(insert instanceof Map<?, ?> map){ //如果insert里还是一个JSON(这里用Map代替，JSON本质就是一个map)，则大概率是图片
                //还是要判断一下，有image字段，才拿
                Optional.ofNullable(map.get("image"))
                        .ifPresent(obj -> images.add(obj.toString()));
            }
        }
        //这里还要切割出前300个字符，因为之前取insert时，可能很长，直接就超300了
        vo.setText(previewText.length() > 300 ? previewText.substring(0, 300) : previewText.toString());
        vo.setImages(images);
        return vo;
    }
```

com/xiaoRed/service/impl/TopicServiceImpl.java
createTopic方法中，一旦有新帖子发布，有关帖子列表的所有缓存需要立即删除
```java
...
if(this.save(topic)){
            //一旦有新帖子发布，有关帖子列表的所有缓存立即删除
            cacheUtil.deleteCachePattern(Const.FORUM_TOPIC_PREVIEW_CACHE + "*");
            return null;
        }
...
```

## 版本二

做到后面的帖子详情的时候，发现既要帖子信息，用户信息，还要用户详细信息，如果按照版本一的思路，就要联三张表，感觉不是很好。而且为了方便以后拆除微服务，应当尽量避免联表查询。

因此返回来，把版本一改了，不要联表查询，用户就查用户信息，帖子就查帖子信息

**具体实现**

com/xiaoRed/config/WebConfiguration.java
不用联表查询，做分页的时候直接使用mybatis-plus的分页器即可
```java
...
//配置mybatis-plus的分页器
    @Bean
    public PaginationInnerInterceptor paginationInnerInterceptor(){
        PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        paginationInnerInterceptor.setMaxLimit(100L);
        return paginationInnerInterceptor;
    }
```

com/xiaoRed/controller/ForumController.java
和版本1对比，就是page变成page+1
```java
/**
     * 根据选定查第几页和选定的帖子类型展示帖子列表
     * @param page 展示的是第几页,由于mybatis-plus分页器的页号从1开始，因此实际要+1
     * @param type 展示的帖子类型，全选则为0
     */
    @GetMapping("/list-topic")
    public RestBean<List<TopicPreviewVo>> listTopic(@RequestParam @Min(0) int page,
                                              @RequestParam @Min(0) int type){
        return RestBean.success(topicService.listTopicByPage(page + 1, type));
    }
```

这次，不往Topic类添加`username`和`avatart`属性

com/xiaoRed/entity/vo/response/TopicPreviewVo.java
```java
/**
 * 帖子列表中，每一个展示的帖子需要的属性封装为一个vo
 */
@Data
public class TopicPreviewVo {
    int id;
    int type;
    String title;
    String text;
    List<String> images;
    Date time;
    Integer uid;
    String username;
    String avatar;
}
```


com/xiaoRed/mapper/TopicMapper.java
版本一那两个联表查询的方法直接删掉即可
```java

```

com/xiaoRed/constants/Const.java
添加展示列表的缓存key的前缀常量
```java
public final static String FORUM_TOPIC_PREVIEW_CACHE = "topic:preview:";
```

com/xiaoRed/service/impl/TopicServiceImpl.java
只是一点小改
```java
@Resource
CacheUtil cacheUtil;

    /**
     * 根据选定查第几页和选定的帖子类型展示帖子列表
     * @param pageNum 展示的是第几页
     * @param type 展示的帖子类型，全选则为0
     */
    @Override
    public List<TopicPreviewVo> listTopicByPage(int pageNum, int type){
        String key = Const.FORUM_TOPIC_PREVIEW_CACHE + pageNum + ":" + type;
        List<TopicPreviewVo> previewVoList = cacheUtil.takeListFromCache(key, TopicPreviewVo.class); //先去缓存里拿
        if (previewVoList != null) return previewVoList; //从缓存中取到，就不用再去数据库里请求了

        Page<Topic> page = Page.of(pageNum, 10); //mybatis-plus的分页器页号是从1开始的
        if(type == 0)
            baseMapper.selectPage(page, Wrappers.<Topic>query().orderByDesc("time"));
        else
            baseMapper.selectPage(page, Wrappers.<Topic>query().eq("type", type).orderByDesc("time"));
        List<Topic> topics = page.getRecords();
        if(topics.isEmpty()) return null;
        previewVoList = topics.stream().map(this::resolveToPreview).toList(); //转化为TopicPreviewVo的列表
        cacheUtil.saveListToCache(key, previewVoList, 60); //拿到要求的帖子列表后，先存到缓存中
        return previewVoList;
    }

   /**
     * 将Topic类型的对象转换为TopicPreviewVo类型的对象
     * 同名属性可以直接bean拷贝
     * 主要就是TopicPreviewVo的text属性和images属性
     * 帖子文本存储在Topic的Content属性的ops数组中的insert字段里，由于只是展示在列表中，只展示前300个字符即可
     * 图片存储在Topic的Content属性的ops数组中的insert字段下的image字段里
     */
    private TopicPreviewVo resolveToPreview(Topic topic){
        TopicPreviewVo vo = new TopicPreviewVo();
        BeanUtils.copyProperties(accountMapper.selectById(topic.getUid()), vo); //用户信息单独查到，把需要的复制给vo
        BeanUtils.copyProperties(topic, vo); //先把topic中的同名属性复制给vo
        List<String> images = new ArrayList<>();
        StringBuilder previewText = new StringBuilder();
        JSONArray ops = JSONObject.parseObject(topic.getContent()).getJSONArray("ops"); //先拿到ops数组
        for(Object ob : ops){
            Object insert = JSONObject.from(ob).get("insert");
            if(insert instanceof String text){ //如果insert里直接就是文本，那其实就是帖子内容
                if(previewText.length()>=300)continue;
                previewText.append(text);
            }else if(insert instanceof Map<?, ?> map){ //如果insert里还是一个JSON(这里用Map代替，JSON本质就是一个map)，则大概率是图片
                //还是要判断一下，有image字段，才拿
                Optional.ofNullable(map.get("image"))
                        .ifPresent(obj -> images.add(obj.toString()));
            }
        }
        //这里还要切割出前300个字符，因为之前取insert时，可能很长，直接就超300了
        System.out.println(previewText);
        vo.setText(previewText.length() > 300 ? previewText.substring(0, 300) : previewText.toString());
        vo.setImages(images);
        return vo;
    }
```

com/xiaoRed/service/impl/TopicServiceImpl.java
createTopic方法中，一旦有新帖子发布，有关帖子列表的所有缓存需要立即删除
```java
...
if(this.save(topic)){
            //一旦有新帖子发布，有关帖子列表的所有缓存立即删除
            cacheUtil.deleteCachePattern(Const.FORUM_TOPIC_PREVIEW_CACHE + "*");
            return null;
        }
...
```





# 展示置顶帖子

给db_topic添加`top`字段，默认是0不置顶，1表示置顶

com/xiaoRed/controller/ForumController.java
```java
    /**
     * 展示置顶帖子
     */
    @GetMapping("top-topic")
    public RestBean<List<TopicTopVo>> TopTopic(){
        return RestBean.success(topicService.listTopTopics());
    }
```

com/xiaoRed/entity/vo/response/TopicTopVo.java
```java
/**
 * 将置顶帖子需要的三个属性封装为vo返回给前端
 */
@Data
public class TopicTopVo {
    int id;
    String title;
    Date time;
}
```

com/xiaoRed/service/impl/TopicServiceImpl.java
```java
    /**
     * 展示置顶帖子
     * 帖子的top字段：0不置顶，1置顶
     */
    @Override
    public List<TopicTopVo> listTopTopics(){
        List<Topic> topics = baseMapper.selectList(Wrappers.<Topic>query()
                .select("id", "title", "time")
                .eq("top", 1));
        return topics.stream().map(topic ->{
            TopicTopVo vo = new TopicTopVo();
            BeanUtils.copyProperties(topic, vo);
            return vo;
        }).toList();
    }
```

# 帖子详情

com/xiaoRed/controller/ForumController.java
```java
    /**
     * 帖子详情
     * @param tid 帖子id
     */
    @GetMapping("/topic")
    public RestBean<TopicDetailVo> Topic(@RequestParam int tid){
        return RestBean.success(topicService.getTopic(tid));
    }
```

com/xiaoRed/entity/vo/response/TopicDetailVo.java
帖子详情分为帖子详细和用户信息
```java
/**
 * 展示帖子详情
 */
@Data
public class TopicDetailVo {

    private Integer id;
    private String title;
    private String content;
    private Integer type;
    private Date time;
    User user;

    @Data
    public static class User{
        Integer id;
        String username;
        String avatar;
        String desc;
        Integer gender;
        String qq;
        String wx;
        String phone;
        String email;
    }
}
```

com/xiaoRed/entity/dto/AccountPrivacy.java
添加一个public方法，返回需要隐私保护的字段名
```java
 //返回需要隐藏的字段名，也就是隐私设置为false，他人不可见的属性
    public String[] hiddenFields() {
        List<String> strings = new LinkedList<>();
        //用反射拿属性，更加灵活，没有写死，方便后续扩展
        Field[] fields = this.getClass().getDeclaredFields(); 
        for (Field field : fields) {
            try {
                if (field.getType().equals(boolean.class) && !field.getBoolean(this))
                    strings.add(field.getName());
            } catch (Exception ignored) {
            }
        }
        return strings.toArray(String[]::new);
    }
```

com/xiaoRed/service/impl/TopicServiceImpl.java
帖子详情包含帖子信息和用户信息，不要联表查询，分开获取即可
```java
    @Resource
    AccountDetailsMapper accountDetailsMapper;
    @Resource
    AccountPrivacyMapper accountPrivacyMapper;
    
    /**
     * 帖子详情
     * 帖子详情包含帖子信息和用户信息，不要联表查询，分开获取即可
     * @param tid 帖子id
     */
    @Override
    public TopicDetailVo getTopic(int tid) {
        TopicDetailVo vo = new TopicDetailVo();
        //封装帖子详情的帖子相关信息
        Topic topic = baseMapper.selectById(tid);
        BeanUtils.copyProperties(topic, vo);
        //封装帖子详情的用户相关信息
        TopicDetailVo.User user = new TopicDetailVo.User();
        vo.setUser(this.fillUserDetailsByPrivacy(user, topic.getUid()));
        return vo;
    }

    /**
     * 获得帖子详情需要的用户信息并返回
     * 注意：需要考虑用户的隐私设置
     * @param target 列表详情需要的用户信息
     * @param uid 用户id
     */
    private <T> T fillUserDetailsByPrivacy(T target, int uid){
        Account account = accountMapper.selectById(uid);
        AccountDetails details = accountDetailsMapper.selectById(uid);
        AccountPrivacy accountPrivacy = accountPrivacyMapper.selectById(uid);
        String[] ignores = accountPrivacy.hiddenFields(); //获得隐私设置中，需要隐藏的属性的字段名
        BeanUtils.copyProperties(account, target, ignores); //将同名属性的值拷贝给target，ignores中的字段将被忽略，不会被拷贝，起到隐私保护作用
        if (details!=null)
            BeanUtils.copyProperties(details, target, ignores); //将同名属性的值拷贝给target，ignores中的字段将被忽略，不会被拷贝，起到隐私保护作用
        return target;

    }
```

# 点赞与收藏

## 需求分析

**分析**
点赞与收藏是一个比较麻烦的功能，考虑到用户可能会疯狂地点赞，取消点赞,...，更新频繁，如果每次都把数据同步更新回数据库，对数据库压力比较大

针对这个问题，可以采用redis缓存，先将一段时间内的点赞/收藏数据存到缓存内，然后再一次性入库；将一段时间内的取消点赞/取消收藏数据存到缓存内，然后再一次性地从数据库中删除
如何制定一段时间？—— 定时器

**设计数据表**
>点赞与收藏的表结构是一样的：谁 + 什么时候 + 点赞/收藏了哪篇文章
>并且需要制定索引，一个用户对同一篇文章只能最多只能有1个数据在表中

点赞：db_topic_interact_like
```sql
CREATE TABLE `db_topic_interact_like` (
  `tid` int(11) NOT NULL,
  `uid` int(11) DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  PRIMARY KEY (`tid`),
  UNIQUE KEY `tid_uid_like` (`tid`,`uid`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

收藏：db_topic_interact_collect
```sql
CREATE TABLE `db_topic_interact_collect` (
  `tid` int(11) NOT NULL,
  `uid` int(11) DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  PRIMARY KEY (`tid`),
  UNIQUE KEY `tid_uid_collect` (`tid`,`uid`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

## 具体实现

com/xiaoRed/controller/ForumController.java
```java
    /**
     * 交互操作：包括帖子点赞，收藏，转发等操作，通过type来区分
     * @param tid 帖子id
     * @param type 交互操作的类型，用正则表达式来做一次校验：like点赞，collect收藏
     * @param state 状态：点赞/收藏为true，取消点赞/取消收藏为false
     * @param uid 用户id
     */
    @GetMapping("/interact")
    public RestBean<Void> interact(@RequestParam int tid,
                                   @RequestParam @Pattern(regexp = "(like|collect)") String type,
                                   @RequestParam boolean state,
                                   @RequestAttribute(Const.ATTR_USER_ID) int uid){
        topicService.interact(new Interact(tid, uid, new Date(), type), state);
        return RestBean.success();
    }
```

com/xiaoRed/entity/dto/Interact.java
点赞，收藏的数据表结构都是一样的，那就把这一类的操作都统一抽象为Interact交互操作，通过type来区分它们
```java
/**
 * 交互操作的信息
 */
@Data
@AllArgsConstructor
public class Interact {
    Integer tid;
    Integer uid;
    Date time;
    String type; //交互类型：点赞like/收藏collect/...

    /**
     * 存储在redis中的交互信息的键为type:tid:uid
     * 这里通过Interact对象生成后缀tid:uid
     */
    public String toKey(){
        return tid + ":" + uid;
    }

    /**
     * 根据外界传来的str和type，解析生成Interact对象返回
     * @param str 存在redis的键为type:tid:uid，实际saveInteract方法中传来的是切割过后的tid:uid
     * @param type 交互操作类型
     */
    public static Interact parseInteract(String str, String type){
        String[] keys = str.split(":");
        return new Interact(Integer.parseInt(keys[0]), Integer.parseInt(keys[1]), new Date(), type);
    }

}
```

com/xiaoRed/service/impl/TopicServiceImpl.java
第一次采用这种思路，值得再记录一下
```java
    /**
     * 交互功能：点赞，收藏
     * 由于论坛交互数据（如点赞、收藏等）更新可能会非常频繁，更新信息实时到MySQL不太现实
     * 所以需要用Redis做缓冲并在合适的时机一次性入库一段时间内的数据
     * 当数据更新到来时，会创建一个新的定时任务，此任务会在一段时间之后执行，将全部Redis暂时缓存的信息一次性加入到数据库，从而缓解MySQL压力
     * 如果在定时任务已经设定期间，又有新的更新到来，仅更新Redis不创建新的延时任务
     * @param interact 交互操作信息
     * @param state 交互操作的状态：点赞/取消点赞，收藏/取消收藏
     */
    @Override
    public void interact(Interact interact, boolean state){
        String type = interact.getType();
        synchronized (type.intern()){ //数据入库过程中，不允许新数据到来(防止可能的数据丢失)
            //这里存到哈希表里，因为点赞/收藏无论外面点多少次，就只有两种结果，相同key的在哈希表中不断覆盖，就留下最终的那次即可
            template.opsForHash().put(type, interact.toKey(),state); //键=type:tid:uid，键值=state
            this.saveInteractSchedule(type); //利用定时任务进行持久化
        }
    }

    private final Map<String, Boolean> state = new HashMap<>(); //记录该类型的任务是否已经开始计时了
    ScheduledExecutorService service = Executors.newScheduledThreadPool(2);
    /**
     * 定时任务
     */
    private void saveInteractSchedule(String type){
        //该类型的任务还没有开始计时/压根就没有这个任务，则创建定时任务
        if(!state.getOrDefault(type, false)){
            state.put(type, true);
            service.schedule(()->{
                this.saveInteract(type);
                state.put(type, false);
            }, 3, TimeUnit.SECONDS); //3s的定时任务
        }
    }

    /**
     * 交互信息持久化
     * 将缓存中点赞/收藏的交互信息一次性入库，将缓存中取消点赞/取消收藏的交互信息从数据库中一次性删除
     * @param type 本次持久化的交互信息的类型
     */
    private void saveInteract(String type){
        synchronized (type.intern()){ //数据入库过程中，不允许新数据到来(防止可能的数据丢失)
            List<Interact> checked =  new LinkedList<>(); //存储缓存中“勾选”的交互信息(即点赞/收藏这种正向的操作)
            List<Interact> cancel = new LinkedList<>(); //存储缓存中”取消“的交互信息
            template.opsForHash().entries(type).forEach((k, v) -> {
                if(Boolean.parseBoolean(v.toString())) //拿到是键值state为true，正向操作
                    checked.add(Interact.parseInteract(k.toString(), type));
                else
                    cancel.add(Interact.parseInteract(k.toString(), type));
            });
            if(!checked.isEmpty())
                baseMapper.addInteract(checked, type);
            if(!cancel.isEmpty())
                baseMapper.deleteInteract(cancel, type);
            template.delete(type);

        }

    }
```

com/xiaoRed/mapper/TopicMapper.java
这里用到了动态sql的foreach循环去处理传进来的列表
```java
    /**
     * 将多条交互信息一次性入库
     * 普通的sql处理不了列表，需要用到mybatis动态sql的foreach进行遍历
     * ignore：遇到相同的数据，就忽略
     * @param interacts 多条交互信息
     * @param type 本次入库的交互信息的类型
     */
    @Insert("""
            <script>
                insert ignore into db_topic_interact_${type} values
                <foreach collection = "interacts" item="item" separator = ",">
                    (#{item.tid}, #{item.uid}, #{item.time})
                </foreach>
            </script>
            """)
    void  addInteract(List<Interact> interacts, String type);

    /**
     * 将多条交互信息一次性删除
     * 普通的sql处理不了列表，需要用到mybatis动态sql的foreach进行遍历
     * @param interacts 多条交互信息
     * @param type 本次入库的交互信息的类型
     */
    @Insert("""
            <script>
                delete from db_topic_interact_${type} where
                <foreach collection = "interacts" item="item" separator = " or ">
                    (tid = #{item.tid} and uid = #{item.uid})
                </foreach>
            </script>
            """)
    void  deleteInteract(List<Interact> interacts, String type);
```

# 交互数据回显

## 需求分析

>目标：帖子列表处可以看到这个帖子的点赞量和收藏量，帖子详情处可以看到当前用户是否点赞/收藏该帖子

**问题**
由于点赞，收藏等交互数据采用定时入库的操作，可能出现以下情况：
用户点完赞后，刷新页面，此时点赞数据还没有入库，前端显示没有点赞

对于帖子详情里的交互数据回显，要求实时，因此，数据回显不能直接从数据库里查，应该先从缓存中查，查到则直接返回，没查到，才去数据库里查

对于帖子列表的交互数据展示，不用更新的那么及时，直接从数据库查也没事

## 具体实现

com/xiaoRed/entity/vo/response/TopicPreviewVo.java
帖子列表预览，添加点赞量和收藏量这两个属性
```java
int like; //展示点赞量
int collect; //展示收藏量
```

com/xiaoRed/entity/vo/response/TopicDetailVo.java
帖子详情，添加Interact内部类属性，展示当前用户是否对该帖子点赞/收藏
```java
@Data
public class TopicDetailVo {
    ...
    Interact interact;

    @Data
    @AllArgsConstructor
    public static class Interact{
        Boolean like; //当前用户是否对该帖子点赞
        Boolean collect;//当前用户是否对该帖子收藏
    }
    ...
}
```

com/xiaoRed/service/impl/TopicServiceImpl.java
帖子详情：vo多封装一个Interact属性，先从缓存里拿，如果缓存没有，再从数据库里拿
帖子列表：将点赞量，收藏量set上即可
```java

public TopicDetailVo getTopic(int tid) {
        ...
        TopicDetailVo.Interact(
                hasInteract(tid, topic.getUid(), "like"),
                hasInteract(tid, topic.getUid(), "collect")
        );
        vo.setInteract(interact);
       ...
        return vo;
    }


private TopicPreviewVo resolveToPreview(Topic topic){
    ...
    vo.setLike(baseMapper.interactCount(topic.getId(), "like"));//点赞量
    vo.setCollect(baseMapper.interactCount(topic.getId(), "collect"));//收藏量
    ...
}

 /**
     * 判断该用户对帖子是否有点赞/收藏
     * 因为有可能数据还没有入库，所以先从缓存里找，如果缓存有对应的key，则直接返回对应的键值
     * 缓存里没有key，才从数据库中找
     * @param tid 帖子id
     * @param uid 用户id
     * @param type 交互类型
     */
    private boolean hasInteract(int tid, int uid, String type){
        String key = tid + ":" + uid;
        //如果缓存里面有，则直接从缓存里拿
        if(template.opsForHash().hasKey(type, key)){
            return Boolean.parseBoolean(template.opsForHash().entries(type).get(key).toString());
        }
        return baseMapper.userInteractCount(tid, uid, type) > 0; //缓存里没有，才从数据库里拿
    }
```

com/xiaoRed/mapper/TopicMapper.java
```java
 /**
     * 返回该帖子对应于交互操作的数量(点赞量多少，收藏量多少...)
     * @param tid 帖子id
     * @param type 交互操作类型
     */
    @Select("select count(*) from db_topic_interact_${type} where tid = #{tid}")
    int interactCount(int tid, String type);

    /**
     * 返回1，说明用户对该帖子点赞/收藏；否则说明没有
     * @param tid 帖子id
     * @param uid 用户id
     * @param type 交互操作的类型
     */
    @Select("select count(*) from db_topic_interact_${type} where tid = #{tid} and uid = #{uid}")
    int userInteractCount(int tid, int uid, String type);
```

