# 账号信息设置

## 前置准备工作

db_account_details数据表存放账号详细信息
```sql
CREATE TABLE db_account_details  (
  `id` int NOT NULL,
  `gender` tinyint(255) NULL,
  `phone` varchar(255) NULL,
  `qq` varchar(255) NULL,
  `wx` varchar(255) NULL,
  `desc` varchar(255) NULL,
  PRIMARY KEY (`id`)
);
```

easycode插件自动生成对应的实体类，service，serviceimpl，mapper

```java
/**
 * (AccountDetails)表实体类
 *
 * @author makejava
 * @since 2023-08-29 15:52:08
 */
@SuppressWarnings("serial")
@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("db_account_details")
public class AccountDetails implements BaseData {
    @TableId
    private Integer id;
    private Integer gender;
    private String phone;
    private String qq;
    private String wx;
    @TableField("`desc`") //desc是sql语句的关键字，需要区分一下
    private String desc;
}

```

## 展示详细信息

com/xiaoRed/entity/vo/response/AccountDetailsVo.java
数据库查询到用户详细信息，封装为AccountDetailsVo对象返回给前端
```java
/**
 * 数据库查询到用户详细信息，封装为vo对象返回给前端
 */
@Data
public class AccountDetailsVo {
    private Integer gender;
    private String phone;
    private String qq;
    private String wx;
    private String desc;
}
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 获取用户详细信息，封装为vo对象，展示到前端
     * @param id JwtAuthorizeFilter已经往请求域中塞进了用户id，直接从请求域里取出来就行
     * @return
     */
    @GetMapping("/details")
    public RestBean<AccountDetailsVo> details(@RequestAttribute(Const.ATTR_USER_ID) int id){
        //如果之前没有保存过账户详细信息，数据表中是没有对应id的数据的，这时new一个空的即可
        AccountDetails accountDetails = Optional.
                ofNullable(accountDetailsService.findAccountDetailsById(id))
                .orElseGet(AccountDetails::new);
        return RestBean.success(accountDetails.asViewObject(AccountDetailsVo.class));
    }
```

com/xiaoRed/service/impl/AccountDetailsServiceImpl.java
```java
    /**
     * 通过用户id从表中找到该条记录并返回给前端显示
     * @param id 用户id
     * @return
     */
    @Override
    public AccountDetails findAccountDetailsById(int id) {
        return this.getById(id);
    }
```

## 保存详细信息

com/xiaoRed/entity/vo/request/DetailsSaveVo.java
将请求中携带的账户信息设置提交的内容封装为一个DetailsSaveVo对象
```java
/**
 * 账户信息设置提交的内容封装为一个vo
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class DetailsSaveVo {
    @Pattern(regexp = "^[a-zA-Z0-9\\u4e00-\\u9fa5]+$")//不允许包含特殊字符
    @Length(min = 1, max = 10)
    private String username;
    //0表示男，1表示女
    @Max(1)
    @Min(0)
    private Integer gender;
    @Length(max = 11)
    private String phone;
    @Length(max = 13)
    private String qq;
    @Length(max = 20)
    private String wx;
    @Length(max = 200)
    private String desc;
}
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 保存账户详细信息
     * @param id JwtAuthorizeFilter已经往请求域中塞进了用户id，直接从请求域里取出来就行
     * @param vo 前端保存账户详细信息表单提交的内容封装为一个vo
     * @return
     */
    @PostMapping("/save-details")
    public RestBean<Void> saveDetails(@RequestAttribute(Const.ATTR_USER_ID) int id, @RequestBody @Valid DetailsSaveVo vo){
        boolean isSuccess = accountDetailsService.saveAccountDetails(id, vo);
        return  isSuccess ? RestBean.success() : RestBean.failure(400, "此用户名已被其他用户使用，请重新设置");
    }
```

com/xiaoRed/service/impl/AccountDetailsServiceImpl.java
```java
    /**
     * 保存账户详细信息，涉及到改两张表
     * 改用户名涉及到db_account表，其他的涉及db_account_details表
     * @param id 用户id
     * @param vo 前端提交的账户详细信息表单
     * @return 是否保存成功
     */
    @Override
    @Transactional
    public boolean saveAccountDetails(int id, DetailsSaveVo vo) {
        Account account = accountService.findAccountByNameOrEmail(vo.getUsername()); //从用户表中查有无同名的用户
        if(account == null || account.getId() == id){ //如果没有同名用户或同名用户就是自己，才可以进一步地修改
            //db_account表中修改用户名
            accountService.update()
                    .eq("id", id)
                    .set("username", vo.getUsername())
                    .update();
            //db_account_details表中修改用户详细信息。如果表中无对应id数据，则插入，否则更新
            this.saveOrUpdate(new AccountDetails(id, vo.getGender(), vo.getPhone(), vo.getQq(),
                    vo.getWx(), vo.getDesc()));
            return true;
        }
        return false;
    }
```

# 修改电子邮箱

com/xiaoRed/entity/vo/request/ModifyEmailVo.java
前端传过来的新电子邮箱以及验证码封装为vo
```java
/**
 * 修改账号绑定的电子邮箱功能：前端传过来的新电子邮箱以及验证码封装为vo
 */
@Data
public class ModifyEmailVo {
    @Email
    String email;
    @Length(max = 6, min = 6)
    String code;
}
```

com/xiaoRed/controller/AuthorizeController.java
请求验证码的方法中，type多一个modify类型，表示修改邮箱
```java
    /**
     * 请求邮件验证码
     * @param type 类型， 必须是register或reset或modify中的一个
     * @param email 请求邮件，必须是合法的邮箱地址才能通过校验
     * @param request 请求，用来获得请求的ip地址
     * @return 是否请求成功
     */
    @GetMapping("/ask-code")
    public RestBean<Void> askVerifyCode(@RequestParam @Pattern(regexp = "(register|reset|modify)") String type, @RequestParam @Email String email,
                                        HttpServletRequest request){
        String message = accountService.sendEmailVerifyCode(type, email, request.getRemoteAddr());
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com/xiaoRed/listener/MailQueueListener.java
消息队列中，发送邮件的方法，新增修改邮箱功能对应的邮件内容
```java
    /**
     * 处理邮件发送
     * @param data 就是生产者发来的消息，包含邮件信息：类型，收件人，验证码
     */
    @RabbitHandler
    public void sendMailMessage(Map<String, Object> data){
        ...
        //不同的type，邮件内容不同
        SimpleMailMessage message = switch (data.get("type").toString()) {
            ...
            case "modify" ->
                    createMailMessage("您的邮箱修改邮件",
                            "您好，您正在绑定新的电子邮箱，验证码: "+code+"，有效时间3分钟，如非本人操作，请无视。",
                            email);
            default -> null;
        };
        if(message == null) return;
        sender.send(message);
    }
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 修改账号绑定的电子邮箱
     * @param id 账号对应的id
     * @param vo 前端传过来的新电子邮箱地址和验证码封装为vo
     * @return
     */
    @PostMapping("/modify-email")
    public RestBean<Void> modifyEmail(@RequestAttribute(Const.ATTR_USER_ID) int id, @RequestBody @Valid ModifyEmailVo vo){
        String message = accountService.modifyEmail(id, vo);
        return message==null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com/xiaoRed/service/impl/AccountServiceImpl.java
```java
    /**
     * 修改账户绑定的电子邮箱功能
     * @param id 执行此操作的账号id
     * @param vo 前端传来的新电子邮箱和验证码封装为vo
     * @return 返回null表示修改成功，修改失败则返回错误信息提示
     */
    @Override
    public String modifyEmail(int id, ModifyEmailVo vo){
        String code = stringRedisTemplate.opsForValue().get(Const.VERIFY_EMAIL_DATA + vo.getEmail()); //拿到redis中存的验证码
        if(code == null) return "请先获取验证码";
        if(!code.equals(vo.getCode())) return "验证码错误，请重新输入";
        Account account = findAccountByNameOrEmail(vo.getEmail());
        if(account!=null && account.getId() != id) return "此电子邮箱已被其他用户使用，请更换一个新的电子邮箱";
        boolean update = this.update()
                .set("email", vo.getEmail())
                .eq("id", id)
                .update();
        if (update){
            //更新数据库成功了，表明修改成功，对应的验证码没用了，手动从redis删除
            stringRedisTemplate.delete(Const.VERIFY_EMAIL_DATA + vo.getEmail());
        }
        return null;
    }
```

# 账号安全设置

## 隐私设置

### 需求及前置

>勾选一次checkbox就发一次请求，也就是一次只会改变一种隐私，不用多个隐私一起改【为了设计请求vo的简便】
和账号详细信息的情况一样，在第一次隐私设置之前，对应id在表中是没有数据的，这时展示隐私设置的情况时，采用的方案是：
直接向前端返回一个默认的隐私对象，而实际上数据表中还没有数据



隐私表
```sql
CREATE TABLE db_account_privacy  (
  `id` int NOT NULL,
  `email` tinyint(255) NULL,
  `gender` tinyint(255) NULL,
  `phone` tinyint(255) NULL,
  `qq` tinyint(255) NULL,
  `wx` tinyint(255) NULL,
  PRIMARY KEY (`id`)
);
```

使用easycode自动生成对应的entity，service，serviceimpl，mapper

AccountPrivacy提供默认值
```java
@Data
@TableName("db_account_privacy")
public class AccountPrivacy implements BaseData {
    @TableId(type = IdType.AUTO)
    final Integer id; //设置为final，表示构造时一定要有
    //0不开启，1开启。默认所有隐私都开启
    private boolean email = true;
    private boolean gender = true;
    private boolean phone = true;
    private boolean qq = true;
    private boolean wx = true;
}
```

com/xiaoRed/service/impl/AccountPrivacyServiceImpl.java
```java
    /**
     * 获得对应账号的隐私权限信息，如果数据库中没有对应的记录，则返回一个默认值（权限全开）
     * @param id
     * @return
     */
    @Override
    public AccountPrivacy getAccountPrivacy(int id){
        return Optional.ofNullable(this.getById(id)).orElse(new AccountPrivacy(id));
    }

```

### 展示隐私设置

com/xiaoRed/entity/vo/response/AccountPrivacyVo.java
响应给前端的隐私设置信息封装为一个vo
```java
/**
 * 响应给前端的隐私设置信息
 */
@Data
public class AccountPrivacyVo {
    private boolean email;
    private boolean gender;
    private boolean phone;
    private boolean qq;
    private boolean wx;
}
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 返回账号的隐私设置，展示在前端
     * @param id
     * @return
     */
    @GetMapping("/privacy")
    public RestBean<AccountPrivacyVo> privacy(@RequestAttribute(Const.ATTR_USER_ID) int id){
        AccountPrivacy accountPrivacy = privacyService.getAccountPrivacy(id);
        return RestBean.success(accountPrivacy.asViewObject(AccountPrivacyVo.class));
    }
```

com/xiaoRed/service/impl/AccountPrivacyServiceImpl.java
```java
    /**
     * 获得对应账号的隐私权限信息，如果数据库中没有对应的记录，则返回一个默认值（权限全开）
     * @param id
     * @return
     */
    @Override
    public AccountPrivacy getAccountPrivacy(int id){
        return Optional.ofNullable(this.getById(id)).orElse(new AccountPrivacy(id));
    }
```

### 保存隐私设置

com/xiaoRed/entity/vo/request/SavePrivacyVo.java
前端修改隐私设置传来的修改种类 + 是否开启封装为一个vo【一次只改一种隐私】
```java
/**
 * 前端修改隐私设置传来的修改种类 + 是否开启封装为一个vo【一次只改一种隐私】
 */
@Data
public class SavePrivacyVo {
    @Pattern(regexp = "email|gender|qq|wx|phone")
    String type;
    boolean status;
}
```


com/xiaoRed/controller/AccountController.java
```java
    /**
     * 保存隐私设置
     * @param id
     * @param vo
     * @return
     */
    @PostMapping("/save-privacy")
    public RestBean<Void> savePrivacy(@RequestAttribute(Const.ATTR_USER_ID) int id, SavePrivacyVo vo){
        privacyService.savePrivacy(id, vo);
        return RestBean.success();
    }
```

com/xiaoRed/service/impl/AccountPrivacyServiceImpl.java
```java
     /**
     * 保存隐私设置：一次只能修改一中隐私
     * @param id
     * @param vo 前端传来的隐私种类 + 是否公开 分装为一个vo
     */
    @Override
    @Transactional
    public void savePrivacy(int id, SavePrivacyVo vo){
        //从数据库查找对应的隐私，如果没有记录，返回默认的隐私对象【权限全开】
        AccountPrivacy privacy = Optional.ofNullable(this.getById(id)).orElse(new AccountPrivacy(id));
        //按照这次传来的隐私种类，修改对应的隐私
        boolean status = vo.isStatus();
        switch (vo.getType()){
            case "phone" -> privacy.setPhone(status);
            case "qq" -> privacy.setQq(status);
            case "wx" -> privacy.setWx(status);
            case "gender" -> privacy.setGender(status);
            case "email" -> privacy.setEmail(status);
        }
        //把改好的隐私再存回数据库
        this.saveOrUpdate(privacy);
    }
```

## 重置密码

>和忘记密码的重置密码功能有相似的地方，但略有不同
这个重置密码是在登录成功状态下完成的，所以逻辑有点不一样

com/xiaoRed/entity/vo/request/ChangePawVo.java
前端传来的原密码，新密码封装为vo
```java
/**
 * 修改密码功能：前端传来的原密码，新密码封装为vo
 */
@Data
public class ChangePawVo {
    @Length(min = 5, max = 20)
    String password_new;
    @Length(min = 5, max = 20)
    String password_old;
}
```

com/xiaoRed/controller/AccountController.java
```java
    /**
     * 修改密码功能【与忘记密码的重置密码区分】
     * @param id 账号id
     * @param vo 前端传来的原密码，新密码封装为vo
     * @return
     */
    @PostMapping("/change-password")
    public RestBean<Void> changePassword(@RequestAttribute(Const.ATTR_USER_ID) int id, @RequestBody @Valid ChangePawVo vo){
        String message = accountService.changePassword(id, vo);
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com/xiaoRed/service/impl/AccountServiceImpl.java
```java
    /**
     * 修改密码功能【和忘记密码的重置密码功能区分】
     * @param id 账号id
     * @param vo 前端传来的原密码，新密码封装为vo
     * @return 返回null说明修改成功，否则返回错误信息提示
     */
    @Override
    public String changePassword(int id, ChangePawVo vo){
        Account account = findAccountById(id);
        String password_db = account.getPassword(); //拿到数据库中存储的密码
        if (!encoder.matches(vo.getPassword_old(), password_db)) return "原密码不正确，重置密码失败"; //如果原密码匹配不上，则修改失败
        //将新密码加密存储到数据库中
        boolean isSuccess = this.update()
                .eq("id", id)
                .set("password", encoder.encode(vo.getPassword_new()))
                .update();
        return isSuccess ? null : "未知错误，请联系管理员";
    }
```

